# -*- coding: utf-8 -*-
"""EliteEstate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tgwnp0Qrelr7eYUGFfFenA76yldj7BI8

#**Housing Market Report**
####Programming group project

Prepared by:

- Andrés Ramírez
- Gonzalo Mir
- Yago Moreno
- Rubén Segura

#Import the used resources / libraries
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from statsmodels.stats.outliers_influence import variance_inflation_factor
from io import BytesIO

#Upload the dataset to your environment

####Upload the 'houses_Madrid.csv' dataset into your environment before running the next cell!!

df_initial = pd.read_csv("houses_Madrid.csv", sep=",")
print(df_initial.info())

"""#Clean the dataframe

#####Clean the dataframe 1: remove the columns with only Nan values
"""

newdf = df_initial.dropna(axis=1, how='all')

"""#####Clean the dataframe 2: keep the important variables, not the specific such as address, portal, and other insignificant variables for our analysis"""

df = newdf.drop(['operation','sq_mt_useful','n_floors','sq_mt_allotment','title','subtitle','raw_address','is_exact_address_hidden',
              'street_name','street_number','neighborhood_id','is_rent_price_known','buy_price_by_area',
              'is_buy_price_known','is_floor_under','is_parking_included_in_price'], axis=1)

"""#####Clean the dataframe 3: change to boolean those variables containing only True or Nan values."""

df[['is_new_development','has_central_heating','has_individual_heating','has_ac','has_fitted_wardrobes','has_lift','is_exterior','has_garden','has_pool','has_terrace','has_balcony','has_storage_room','is_accessible','has_green_zones','is_orientation_north','is_orientation_south','is_orientation_east','is_orientation_west']] = df[['is_new_development','has_central_heating','has_individual_heating','has_ac','has_fitted_wardrobes','has_lift','is_exterior','has_garden','has_pool','has_terrace','has_balcony','has_storage_room','is_accessible','has_green_zones','is_orientation_north','is_orientation_south','is_orientation_east','is_orientation_west']].fillna(False)

"""#####Clean the dataframe 4: change the Nan values in the variables 'parking_price' and 'built_year' as boolean values would not make sense"""

df['parking_price']=df['parking_price'].fillna('No parking')
df['parking_price']=df['parking_price'].fillna('No data')

"""#####Clean the dataframe 5: Eliminate the rows with Nan values from the variables. By doing this we will have the same number of useful rows for all variables. If we did this in the first step, we would have eliminated practically all rows, as the previously eliminated variables contained many Nan values."""

df = df.dropna()

"""#####Clean the dataframe 6: eliminate all the duplicates inside the dataframe"""

df = df.drop_duplicates()
print(df.info())

"""#####Code for creating the file that will create the document called 'Report' where all the results will be printed"""

with open('Report.txt', 'w') as file:
    file.write('RESULTS FROM ELITE ESTATE\n\n')

"""#VISUALS

####Histogram showing the number of houses / distribution per price
"""

#Firstly, we need to remove the outliers. Therefore, we calculate the upper
#and lower bonds of the values and create a new dataset with the values in
#between these bonds. Then, we create the histogram with the relevant data

Q1 = df['buy_price'].quantile(0.25)
Q3 = df['buy_price'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
outliers = (df['buy_price'] < lower_bound) | (df['buy_price'] > upper_bound)
df_no_outliers = df[~outliers]

#Now, make the histogram using plotly library
plt.xlabel('Buy Price')
plt.ylabel('Frequency')
plt.title('Histogram of Buy Price (Without Outliers)')
df_no_outliers['buy_price'].hist(bins=20, color='blue', edgecolor='black')
plt.show()
median_price = df_no_outliers['buy_price'].median()
mean_price = df_no_outliers['buy_price'].mean()

#Saving results in the external document
a = BytesIO()
plt.savefig(a, format='png')

with open('Report.txt', 'a') as file:
    file.write('HISTOGRAM SHOWING THE DISTRIBUTION BASED ON PRICE\n')
    file.write(f'Median of Buy Price (without outliers): {median_price:.2f}€\n')
    file.write(f'Mean of Buy Price (without outliers): {mean_price:.2f}€\n')
    file.write('\n\n\n\n')

"""####Correlation between the price of houses and their built square meters"""

sns.scatterplot(x='sq_mt_built', y='buy_price', data=df, color = 'green')
plt.xlabel('Square Meters Built')
plt.ylabel('Buy Price')
plt.title('Correlation between price and built sqm')
sns.regplot(x='sq_mt_built', y='buy_price', data=df, scatter = False, color='blue')
plt.ticklabel_format(style='plain', axis='y')
plt.show()
correlation = df['sq_mt_built'].corr(df['buy_price'])
print(f"\nLinear Regression Coefficient: {correlation:.3f}")

#Save the plot and results in the document

scatplot1 = BytesIO()
plt.savefig(scatplot1, format='png')

with open('Report.txt', 'a') as file:
    file.write('CORRELATION BETWEEN THE PRICE OF HOUSES AND THEIR BUILT SQUARE METERS\n')
    file.write(f'The Linear Regression Coefficient is {correlation:.3f}')
    file.write('\n\n\n\n')

"""####Rent price distribution based on renewal needs"""

#Remove outliers from the df using the IQ method
Q1 = df['rent_price'].quantile(0.25)
Q3 = df['rent_price'].quantile(0.75)
IQR = Q3 - Q1
lower_limit = Q1 - 1.5 * IQR
upper_limit = Q3 + 1.5 * IQR
df_filtered = df[(df['rent_price'] >= lower_limit) & (df['rent_price'] <= upper_limit)]

#Boxplot creation
df_filtered.loc[:, 'is_renewal_needed'] = df_filtered['is_renewal_needed'].copy()
sns.boxplot(x='is_renewal_needed', y='rent_price', data=df_filtered, palette='Set2', hue='is_renewal_needed', legend=False)

plt.title('Rent Price Distribution based on Renewal Needs')
plt.xlabel('Renewal Needed')
plt.ylabel('Rent Price')

#We wanted to put a legend but the format we used afterwards was not working.
#That's why we looked on the internet how to do it. Thus, the code may seem more professional.
colors = sns.color_palette('Set2')
legend_labels = ['Renewal Not Needed', 'Renewal Needed']
legend_patches = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10) for color in colors]
plt.legend(legend_patches, legend_labels,loc='upper right')
plt.show()

#Relevant data from the boxplot

median_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 1]['rent_price'].median()
q1_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 1]['rent_price'].quantile(0.25)
q3_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 1]['rent_price'].quantile(0.75)
mean_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 1]['rent_price'].mean()

median_not_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 0]['rent_price'].median()
q1_not_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 0]['rent_price'].quantile(0.25)
q3_not_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 0]['rent_price'].quantile(0.75)
mean_not_renewal_needed = df_filtered[df_filtered['is_renewal_needed'] == 0]['rent_price'].mean()

#Save the results into the document
b = BytesIO()
plt.savefig(b, format='png')

with open('Report.txt', 'a') as file:
    file.write('RENT PRICE DISTRIBUTION BASED ON RENEWAL NEEDS\n')
    file.write(f'Statistics for Renewal Needed:\n')
    file.write(f'Median={median_renewal_needed}, Q1={q1_renewal_needed}, Q3={q3_renewal_needed}, Mean={mean_renewal_needed}\n')
    file.write('Statistics for Renewal Not Needed:\n')
    file.write(f'Median={median_not_renewal_needed}, Q1={q1_not_renewal_needed}, Q3={q3_not_renewal_needed}, Mean={mean_not_renewal_needed}')
    file.write('\n\n\n\n')


"""####Grouped bar chart containing the number of homes per type and their respective heating system"""

#Create the plot

feature_counts = df.groupby('house_type_id').agg(
    {'has_central_heating': 'sum', 'has_individual_heating': 'sum'}
).reset_index()
fig, ax = plt.subplots()
ax.bar(feature_counts['house_type_id'], feature_counts['has_central_heating'], label='Central Heating')
ax.bar(feature_counts['house_type_id'], feature_counts['has_individual_heating'], bottom=feature_counts['has_central_heating'], label='Individual Heating')
ax.set_ylabel('Number of Properties')
ax.set_xlabel('Property Type')
ax.set_title('Distribution of Property Types Based on Features')
ax.legend()
plt.show()

#Save the results in the document
grouped1 = BytesIO()
plt.savefig(grouped1, format='png')
feature_counts_str = feature_counts.to_string(index = False)

with open('Report.txt', 'a') as file:
    file.write('GROUPED BAR CHART WITH THE NUMBER OF HOMES PER TYPE AND HEATING SYSTEM\n')
    file.write("The count of the type of heating and home type:\n")
    file.write(feature_counts_str)
    file.write('\n\n\n\n')

"""####Pie chart displaying the distribution of sold houses depending on their orientation"""

#Make the pie chart

orientation_columns = ['is_orientation_north', 'is_orientation_west', 'is_orientation_south', 'is_orientation_east']
orientation_data = df[orientation_columns]
orientation_counts = orientation_data.sum()
plt.pie(orientation_counts, labels=orientation_counts.index,autopct='%1.1f%%')
plt.title('Distribution of Orientations')
plt.show()

#Save the percentages into separate variables

total_orientations = orientation_counts.sum()
percentage_north = (orientation_counts['is_orientation_north'] / total_orientations) * 100
percentage_west = (orientation_counts['is_orientation_west'] / total_orientations) * 100
percentage_south = (orientation_counts['is_orientation_south'] / total_orientations) * 100
percentage_east = (orientation_counts['is_orientation_east'] / total_orientations) * 100

#Save the plot and the results in the document
piechart1 = BytesIO()
plt.savefig(piechart1, format='png')

with open('Report.txt', 'a') as file:
    file.write('PIECHART SHOWING THE DISTRIBUTION OF HOUSES BASED ON ORIENTATION\n')
    file.write(f"Percentage North: {percentage_north}%\n")
    file.write(f"Percentage South: {percentage_south}%\n")
    file.write(f"Percentage West: {percentage_west}%\n")
    file.write(f"Percentage East: {percentage_east}%\n")
    file.write('\n\n\n\n')

"""####Line chart showing the evolution of construction during the years"""

#Line chart build

df['built_year'] = pd.to_numeric(df['built_year'], errors='coerce')
df = df.dropna(subset=['built_year'])
df = df[(df['built_year'] > 1900) & (df['built_year'] <= 2023)]
construction_data = df.groupby('built_year').size().reset_index(name='property_count')
plt.plot(construction_data['built_year'], construction_data['property_count'])
plt.title('Number of Properties Built Each Year')
plt.xlabel('Year of Construction')
plt.ylabel('Number of Properties')
plt.show()

#Maximums and minimums obtaining

three_max_values = construction_data.nlargest(3, 'property_count')
three_min_values = construction_data.nsmallest(3, 'property_count')

#Save the results in the document
linechart1 = BytesIO()
plt.savefig(linechart1, format='png')

with open('Report.txt', 'a') as file:
    file.write('LINECHART SHOWING THE NUMBER OF BUILT HOMES PER YEAR\n')
    file.write(f"Top 3 Years with Most Properties Built:\n{three_max_values}\n")
    file.write(f"Top 3 Years with Least Properties Built:\n{three_min_values}\n")
    file.write('\n\n\n\n')

"""#PREDICTOR

#####Using less variables to increase the accuracy of the model
"""

#The model to obtain the intercept value and the coefficients (beta values)
# of each independent variable

X = df[['n_rooms','n_bathrooms','sq_mt_built','has_parking']]
y = df['buy_price']
X.loc[:, 'has_parking'] = X['has_parking'].astype(int)
X = X.astype(float)
model = LinearRegression()
model.fit(X, y)
intercept = model.intercept_
coefficients = model.coef_
print(intercept)
print(coefficients)

#The predictor using OOP

class Predictor:
    def __init__(self, n_rooms, n_bathrooms, sq_mt_built,has_parking):
        self.n_rooms = n_rooms
        self.n_bathrooms = n_bathrooms
        self.sq_mt_built = sq_mt_built
        self.has_parking = has_parking

    def calculator(self):
        n_roomsv = 91543.18
        n_bathroomsv = 102509.02
        sq_mt_builtv = 6077.9
        has_parkingv = 75195.16
        intercept = 120692.33
        resultprice = intercept + self.n_rooms * n_roomsv + self.n_bathrooms * n_bathroomsv + self.sq_mt_built * sq_mt_builtv + self.has_parking*has_parkingv
        return resultprice

answ = input('\n\n\n\n\nWELCOME TO ELITE ESTATE PRICE PREDICTOR, FILL OUT THIS QUESTIONNAIRE TO KNOW THE PRICE OF YOUR HOME.\nIF YOU DO NOT WANT TO CONTINUE, JUST TYPE "EXIT" AND THE PROGRAM WILL STOP. \n\n\n\n\n\n\nDO YOU WANT TO PREDICT THE PRICE OF YOUR HOME?\n')
if answ.lower() == 'exit':
    print("Goodbye!\nRemember to take a look at the 'Results.txt' document saved into\nyour environment for further understanding of the data")
    exit()
if answ.lower() != 'yes':
    print("Invalid input. Please type 'yes' to continue or 'exit' to stop.")
    exit()

a = int(input('GREAT!\nHow many rooms does the house have?\n'))
b = int(input('How many bathrooms does the house have?\n'))
c = int(input('How many square meters built does the house have?\n'))
d = input('Does it have parking?\n')
if d.lower() == 'yes':
  d = 1
else:
  d = 0
my_predictor = Predictor(a, b, c,d)
result = my_predictor.calculator()

print(f'The price of the home would be {result:.2f}€\nRemember to take a look at the 'Results.txt' document saved into\nyour environment for further understanding of the data')

"""#####We tried doing the predictor with most of the independent binary variables, such as 'has_ac', 'has_garden',etc. However, the predictor results were not accurate as most of the independent variables have high multicolinearity with the dependent variable. With high multicolinearity, the individual contribution of each parameter (independent variable) is difficult to assess."""

#The proof of it

X = df[['has_central_heating', 'has_ac', 'has_fitted_wardrobes', 'has_lift', 'is_exterior',
        'has_garden', 'has_pool', 'has_terrace', 'has_balcony', 'has_storage_room',
        'is_accessible', 'has_green_zones', 'has_parking']]
y = df['buy_price']
X = X.astype(float)

def calculate_vif(data_frame):
    vif_data = pd.DataFrame()
    vif_data["feature"] = data_frame.columns
    vif_data["VIF"] = [variance_inflation_factor(data_frame.values, i) for i in range(data_frame.shape[1])]
    return vif_data
#vif_data = calculate_vif(X)

#model = LinearRegression()
#model.fit(X, y)
#intercept = model.intercept_
#coefficients = model.coef_
##print(intercept)
##print(coefficients)

#Values do not make sense
